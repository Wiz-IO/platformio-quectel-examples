/*********************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.7.
 *
 * Generated Date: 12/24/2019
 *********************************************************************************************/

#include "pnp_device.h"

// The protocol you wish to use should be uncommented
//
#define SAMPLE_MQTT
//#define SAMPLE_MQTT_OVER_WEBSOCKETS
//#define SAMPLE_AMQP
//#define SAMPLE_AMQP_OVER_WEBSOCKETS
//#define SAMPLE_HTTP

#ifdef SAMPLE_MQTT
    #include "iothubtransportmqtt.h"
#endif // SAMPLE_MQTT
#ifdef SAMPLE_MQTT_OVER_WEBSOCKETS
    #include "iothubtransportmqtt_websockets.h"
#endif // SAMPLE_MQTT_OVER_WEBSOCKETS
#ifdef SAMPLE_AMQP
    #include "iothubtransportamqp.h"
#endif // SAMPLE_AMQP
#ifdef SAMPLE_AMQP_OVER_WEBSOCKETS
    #include "iothubtransportamqp_websockets.h"
#endif // SAMPLE_AMQP_OVER_WEBSOCKETS
#ifdef SAMPLE_HTTP
    #include "iothubtransporthttp.h"
#endif // SAMPLE_HTTP

#ifdef SET_TRUSTED_CERT_IN_SAMPLES
#include "certs.h"
#endif // SET_TRUSTED_CERT_IN_SAMPLES

#include "parson.h"

#define PROXY_PORT                  8888
#define MESSAGES_TO_SEND            2
#define TIME_BETWEEN_MESSAGES       2

// Number of Digital Twins interfaces that this device supports.
#define DIGITALTWIN_INTERFACE_NUM 2

#define DEVICEINFO_INDEX 0

#define SENSOR_INDEX 1

#define SDKInfo_INDEX 2


#define DEFAULT_SEND_TELEMETRY_INTERVAL_MS 10000

#define DEVICE_CAPABILITY_MODEL_URI "urn:dmd9205:sample_device:1"

static DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceClientHandles[DIGITALTWIN_INTERFACE_NUM];
static DIGITALTWIN_DEVICE_CLIENT_LL_HANDLE digitalTwinDeviceClientHandle = NULL;

extern bool bSendingEnds ;
//static TICK_COUNTER_HANDLE tickcounter = NULL;
//static tickcounter_ms_t lastTickSend;
typedef struct CLIENT_SAMPLE_INFO_TAG
{
    unsigned int sleep_time;
    char* iothub_uri;
    char* access_key_name;
    char* device_key;
    char* device_id;
    int registration_complete;
} CLIENT_SAMPLE_INFO;

typedef struct IOTHUB_CLIENT_SAMPLE_INFO_TAG
{
    int connected;
    int stop_running;
} IOTHUB_CLIENT_SAMPLE_INFO;

static void register_device_callback(PROV_DEVICE_RESULT register_result, const char* iothub_uri, const char* device_id, void* user_context)
{
    if (user_context == NULL)
    {
        LogInfo("user_context is NULL\r\n");
    }
    else
    {
        CLIENT_SAMPLE_INFO* user_ctx = (CLIENT_SAMPLE_INFO*)user_context;
        if (register_result == PROV_DEVICE_RESULT_OK)
        {
            LogInfo("Registration Information received from service: %s!\r\n", iothub_uri);
            (void)mallocAndStrcpy_s(&user_ctx->iothub_uri, iothub_uri);
            (void)mallocAndStrcpy_s(&user_ctx->device_id, device_id);
            user_ctx->registration_complete = 1;
        }
        else
        {
            //LogInfo("Failure encountered on registration %s\r\n", MU_ENUM_TO_STRING(PROV_DEVICE_RESULT, register_result) );
            user_ctx->registration_complete = 2;
        }
    }
}

static void registration_status_callback(PROV_DEVICE_REG_STATUS reg_status, void* user_context)
{
    (void)user_context;
	LogInfo("registration status callback.\r\n");
    //LogInfo("Provisioning Status: %s\r\n", MU_ENUM_TO_STRING(PROV_DEVICE_REG_STATUS, reg_status));
}

static void iothub_connection_status(IOTHUB_CLIENT_CONNECTION_STATUS result, IOTHUB_CLIENT_CONNECTION_STATUS_REASON reason, void* user_context)
{
    (void)reason;
    if (user_context == NULL)
    {
        LogInfo("iothub_connection_status user_context is NULL\r\n");
    }
    else
    {
        IOTHUB_CLIENT_SAMPLE_INFO* iothub_info = (IOTHUB_CLIENT_SAMPLE_INFO*)user_context;
        if (result == IOTHUB_CLIENT_CONNECTION_AUTHENTICATED)
        {
            iothub_info->connected = 1;
        }
        else
        {
            iothub_info->connected = 0;
            iothub_info->stop_running = 1;
        }
    }
}

static char* getConStringFromUser_ctx(CLIENT_SAMPLE_INFO user_ctx)
{
    char* conString = NULL;

	sprintf(conString,"HostName=%s;DeviceId=%s;SharedAccessKey=%s",user_ctx.iothub_uri,user_ctx.device_id,user_ctx.access_key_name);
	return conString;
}


int pnp_device_initialize(char * symm_auth,const char* trustedCert)
{

    DIGITALTWIN_CLIENT_RESULT result;				

    SECURE_DEVICE_TYPE hsm_type;
    //hsm_type = SECURE_DEVICE_TYPE_TPM;
    //hsm_type = SECURE_DEVICE_TYPE_X509;
    hsm_type = SECURE_DEVICE_TYPE_SYMMETRIC_KEY;

    bool traceOn = false;
	
    PROV_DEVICE_TRANSPORT_PROVIDER_FUNCTION prov_transport;
    HTTP_PROXY_OPTIONS http_proxy;
    CLIENT_SAMPLE_INFO user_ctx;

	static const char* global_prov_uri = "global.azure-devices-provisioning.net";
    static const char* id_scope = NULL,*sasKey = NULL,*deviceId = NULL;

    static bool g_registration_complete = false;
    //static bool g_use_proxy = false;
    //static const char* PROXY_ADDRESS = "127.0.0.1";

    (void)IoTHub_Init();

    /******************JSON PARSE*****************/
    LogInfo("func:%s line:%d parson:%s\r\n",__func__,__LINE__,symm_auth);
    LogInfo("___________________________________________________\r\n");
    JSON_Value *root_value = json_parse_string(symm_auth);
    LogInfo("___________________________________________________\r\n");

    if(root_value == NULL)
    {
        LogInfo("root_value == NULL\r\n");
    }else{
        LogInfo("json_parse_string successful\r\n");
    }

    JSON_Object *root_object = json_value_get_object(root_value);

    if(root_object == NULL)
    {
        LogInfo("root_object == NULL\r\n");
    }else{
        LogInfo("json_value_get_object successful\r\n");
    }


    char * SasKeyJ = NULL,*DpsIdScopeJ = NULL,*RegisterIdJ = NULL;
    
    if ((SasKeyJ = json_object_get_string(root_object, "SasKey") )!= NULL)
    {
        LogInfo("sasKeyjson:%s\r\n", SasKeyJ);
    }else{
        LogInfo("can't get string from json1........\n");
    }
        
    if ((DpsIdScopeJ = json_object_get_string(root_object, "DpsIdScope")) != NULL )
    {
        LogInfo("dpsIdScopejson:%s\r\n", DpsIdScopeJ);
    }else{
        LogInfo("can't get string from json2........\n");
    }
        
    if ((RegisterIdJ = json_object_get_string(root_object, "RegisterId")) != NULL)
    {
        LogInfo("deviceIdjson:%s\r\n", RegisterIdJ);
    }else{
        LogInfo("can't get string from json3........\n");
    }

    deviceId = RegisterIdJ;
    id_scope = DpsIdScopeJ;
    sasKey = SasKeyJ;

    LogInfo("=============>sasKey:%s\r\n", sasKey);
    LogInfo("=============>dpsIdScope:%s\r\n", id_scope);
    LogInfo("=============>deviceId:%s\r\n", deviceId);
    /*********************************************/

    (void)prov_dev_security_init(hsm_type);	
    // Set the symmetric key if using they auth type
    //prov_dev_set_symmetric_key_info("bg95demo1", "B1UbggvfYkOxIAK115roJgiNL1TRyjrllKZB6nmnWzk=");
    prov_dev_set_symmetric_key_info(deviceId, sasKey);

	memset(&interfaceClientHandles, 0, sizeof(interfaceClientHandles));
    memset(&http_proxy, 0, sizeof(HTTP_PROXY_OPTIONS));
    memset(&user_ctx, 0, sizeof(CLIENT_SAMPLE_INFO));

    // Protocol to USE - HTTP, AMQP, AMQP_WS, MQTT, MQTT_WS
#ifdef SAMPLE_MQTT
    prov_transport = Prov_Device_MQTT_Protocol;
#endif // SAMPLE_MQTT
#ifdef SAMPLE_MQTT_OVER_WEBSOCKETS
    prov_transport = Prov_Device_MQTT_WS_Protocol;
#endif // SAMPLE_MQTT_OVER_WEBSOCKETS
#ifdef SAMPLE_AMQP
    prov_transport = Prov_Device_AMQP_Protocol;
#endif // SAMPLE_AMQP
#ifdef SAMPLE_AMQP_OVER_WEBSOCKETS
    prov_transport = Prov_Device_AMQP_WS_Protocol;
#endif // SAMPLE_AMQP_OVER_WEBSOCKETS
#ifdef SAMPLE_HTTP
    prov_transport = Prov_Device_HTTP_Protocol;
#endif // SAMPLE_HTTP

    // Set ini
    user_ctx.registration_complete = 0;
    user_ctx.sleep_time = 10;

    LogInfo("Provisioning API Version: %s\r\n", Prov_Device_LL_GetVersionString());
    LogInfo("Iothub API Version: %s\r\n", IoTHubClient_GetVersionString());

    //if (g_use_proxy)
    //{
    //    http_proxy.host_address = PROXY_ADDRESS;
    //    http_proxy.port = PROXY_PORT;
    //}

    PROV_DEVICE_LL_HANDLE handle;
    if ((handle = Prov_Device_LL_Create(global_prov_uri, id_scope, prov_transport)) == NULL)
    {
        LogInfo("failed calling Prov_Device_LL_Create\r\n");
    }
    else
    {
        if (http_proxy.host_address != NULL)
        {
            Prov_Device_LL_SetOption(handle, OPTION_HTTP_PROXY, &http_proxy);
        }

        Prov_Device_LL_SetOption(handle, PROV_OPTION_LOG_TRACE, &traceOn);
#ifdef SET_TRUSTED_CERT_IN_SAMPLES
        // Setting the Trusted Certificate.  This is only necessary on system with without
        // built in certificate stores.
        Prov_Device_LL_SetOption(handle, OPTION_TRUSTED_CERT, certificates);
#endif // SET_TRUSTED_CERT_IN_SAMPLES

        // This option sets the registration ID it overrides the registration ID that is 
        // set within the HSM so be cautious if setting this value
        //Prov_Device_SetOption(prov_device_handle, PROV_REGISTRATION_ID, "[REGISTRATION ID]");

        if (Prov_Device_LL_Register_Device(handle, register_device_callback, &user_ctx, registration_status_callback, &user_ctx) != PROV_DEVICE_RESULT_OK)
        {
            LogInfo("failed calling Prov_Device_LL_Register_Device\r\n");
        }
        else
        {
            do
            {
                Prov_Device_LL_DoWork(handle);
                ThreadAPI_Sleep(user_ctx.sleep_time);
            } while (user_ctx.registration_complete == 0);
        }
       // Prov_Device_LL_Destroy(handle);
    }

    if (user_ctx.registration_complete != 1)
    {
        LogInfo("registration failed!\r\n");
    }
    else
    {
    		LogInfo("handle=%d\r\n",handle);
        IOTHUB_CLIENT_TRANSPORT_PROVIDER iothub_transport;

        // Protocol to USE - HTTP, AMQP, AMQP_WS, MQTT, MQTT_WS
#if defined(SAMPLE_MQTT) || defined(SAMPLE_HTTP) // HTTP sample will use mqtt protocol
        iothub_transport = MQTT_Protocol;
#endif // SAMPLE_MQTT
#ifdef SAMPLE_MQTT_OVER_WEBSOCKETS
        iothub_transport = MQTT_WebSocket_Protocol;
#endif // SAMPLE_MQTT_OVER_WEBSOCKETS
//#ifdef SAMPLE_AMQP
        //iothub_transport = AMQP_Protocol;
//#endif // SAMPLE_AMQP
#ifdef SAMPLE_AMQP_OVER_WEBSOCKETS
        iothub_transport = AMQP_Protocol_over_WebSocketsTls;
#endif // SAMPLE_AMQP_OVER_WEBSOCKETS

        IOTHUB_DEVICE_CLIENT_LL_HANDLE device_ll_handle = NULL;
		

        LogInfo("Creating IoTHub Device handle\r\n");
		LogInfo("user_ctx.iothub_uri=%s\r\n",user_ctx.iothub_uri);
		LogInfo("user_ctx.device_id=%s\r\n",user_ctx.device_id);
		
        if ((device_ll_handle = IoTHubDeviceClient_LL_CreateFromDeviceAuth(user_ctx.iothub_uri, user_ctx.device_id, iothub_transport) ) == NULL)
        {
            LogInfo("failed create IoTHub client from connection string %s!\r\n", user_ctx.iothub_uri);
			IoTHubDeviceClient_LL_Destroy(device_ll_handle);
        }
        else
        {
        	LogInfo("IoTHub Device handle=%d\r\n",device_ll_handle);
            IOTHUB_CLIENT_SAMPLE_INFO iothub_info;
            iothub_info.stop_running = 0;
            iothub_info.connected = 0;

            //IOTHUB_CLIENT_RESULT result1 = IoTHubDeviceClient_LL_SetConnectionStatusCallback(device_ll_handle, iothub_connection_status, &iothub_info);
			//if (result1 != IOTHUB_CLIENT_OK)
			//{
			//	LogInfo("DigitalTwin_DeviceClient_CreateFromDeviceHandle failed, error: %d, %s",result,MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
			//}

            // Set any option that are neccessary.
            // For available options please see the iothub_sdk_options.md documentation

            IoTHubDeviceClient_LL_SetOption(device_ll_handle, OPTION_LOG_TRACE, &traceOn);

#ifdef SET_TRUSTED_CERT_IN_SAMPLES
            // Setting the Trusted Certificate.  This is only necessary on system with without
            // built in certificate stores.
            IoTHubDeviceClient_LL_SetOption(device_ll_handle, OPTION_TRUSTED_CERT, certificates);
#endif // SET_TRUSTED_CERT_IN_SAMPLES

           // (void)IoTHubDeviceClient_LL_SetMessageCallback(device_ll_handle, pnp_receive_msg_callback, &iothub_info);
				//result = DigitalTwin_DeviceClient_LL_CreateFromDeviceHandle(device_ll_handle,&digitalTwinDeviceClientHandle);

             	//LogInfo("iothub_info.connected=%d,iothub_info.stop_running=%d\r\n",iothub_info.connected,iothub_info.stop_running);
                //if (iothub_info.connected != 0)
                if (true)
                {
                     result = DigitalTwin_DeviceClient_LL_CreateFromDeviceHandle(device_ll_handle,&digitalTwinDeviceClientHandle);
                     //char* ConnectionString = NULL;
					 //ConnectionString = getConStringFromUser_ctx(user_ctx);
					 //LogInfo("ConnectionString=%s\r\n",ConnectionString);
                     //if ((digitalTwinDeviceClientHandle = DigitalTwinClientHelper_InitializeDeviceHandle(ConnectionString, false, trustedCert)) == NULL)
    				 //{
        			///	LogError("DigitalTwinClientHelper_InitializeDeviceHandle failed");
        			//	return -1;
    				 //}
					LogInfo("\r\ndigitalTwinDeviceClientHandle=%d\r\n",digitalTwinDeviceClientHandle);
				    
				    if (result != DIGITALTWIN_CLIENT_OK)
				    {
					    LogInfo("DigitalTwin_DeviceClient_CreateFromDeviceHandle failed, error: %d, %s",result,MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
					}

                }
				else
				{
				    free(user_ctx.iothub_uri);
                    free(user_ctx.device_id);
				
					prov_dev_security_deinit();
					// Free all the sdk subsystem
    				IoTHub_Deinit();
				}
				
      // Initialize DigitalTwin device handle
   // if ((digitalTwinDeviceClientHandle = DigitalTwinClientHelper_InitializeDeviceHandle(connectionString, false, trustedCert)) == NULL)
   // {
   //     LogError("DigitalTwinClientHelper_InitializeDeviceHandle failed");
   //     return -1;
   // }

    // Invoke to the ***Interface_Create - implemented in a separate library - to create DIGITALTWIN_INTERFACE_CLIENT_HANDLE.
    // NOTE: Other than creation and destruction, NO operations may occur on any DIGITALTWIN_INTERFACE_CLIENT_HANDLE
    // until after we've completed its registration (see DigitalTwinClientHelper_RegisterInterfacesAndWait).

    		if ((interfaceClientHandles[DEVICEINFO_INDEX] = DeviceinfoInterface_Create(digitalTwinDeviceClientHandle)) == NULL)
    		{
        		LogError("DeviceinfoInterface_Create failed");
        		return -1;
    		}

    		if ((interfaceClientHandles[SENSOR_INDEX] = SensorInterface_Create(digitalTwinDeviceClientHandle)) == NULL)
    		{
        		LogError("SensorInterface_Create failed");
   	     		return -1;
   	 		}

    		/*if ((interfaceClientHandles[SDKInfo_INDEX] = SDKinfoInterface_Create(digitalTwinDeviceClientHandle)) == NULL)
			{
				LogError("SDKinfoInterface_Create failed");
				return -1;
			}*/

    	// Register the interface(s) we've created with Azure IoT.  This call will block until interfaces
    	// are successfully registered, we get a failure from server, or we timeout.
    		if (DigitalTwinClientHelper_RegisterInterfacesAndWait(digitalTwinDeviceClientHandle, DEVICE_CAPABILITY_MODEL_URI, interfaceClientHandles, DIGITALTWIN_INTERFACE_NUM) != DIGITALTWIN_CLIENT_OK)
    		{
        		LogError("DigitalTwinClientHelper_RegisterInterfacesAndWait failed");
        		return -1;
    		}

    		DigitalTwinClientHelper_Check(digitalTwinDeviceClientHandle);

    		// report properties
			//LogInfo("func:%s line:%d........\n",__func__,__LINE__);
    		DeviceinfoInterface_Property_ReportAll(digitalTwinDeviceClientHandle);
    		SensorInterface_Property_ReportAll(digitalTwinDeviceClientHandle);

            DigitalTwinClientHelper_Check(digitalTwinDeviceClientHandle);
        }
    }
	return 0;

}

void pnp_device_run(char* lat, char* lon)
{   
    #if 0
    tickcounter_ms_t nowTick;
    tickcounter_get_current_ms(tickcounter, &nowTick);

    if (nowTick - lastTickSend >= DEFAULT_SEND_TELEMETRY_INTERVAL_MS)
    {
        LogInfo("Send telemetry data to IoT Hub");

        SensorInterface_Telemetry_SendAll();

        tickcounter_get_current_ms(tickcounter, &lastTickSend);
    }
    else
    {
        // Just check data from IoT Hub
        DigitalTwinClientHelper_Check();
    }
    #else
    LogInfo("pnp_device_run\r\n");
	
	if (lat != NULL && lon != NULL)
	{

		SensorInterface_Telemetry_Location(lat, lon);

	}
	else
	{
		SensorInterface_Telemetry_SendAll();
	}

	LogInfo("Check\r\n");
	DigitalTwinClientHelper_Check(digitalTwinDeviceClientHandle);
	

    #endif
}

void pnp_device_close()
{
    if (interfaceClientHandles[DEVICEINFO_INDEX] != NULL)
    {
        DeviceinfoInterface_Close(interfaceClientHandles[DEVICEINFO_INDEX]);
    }

    if (interfaceClientHandles[SENSOR_INDEX] != NULL)
    {
        SensorInterface_Close(interfaceClientHandles[SENSOR_INDEX]);
    }

    DigitalTwinClientHelper_DeInitialize();
	
	// Free all the sdk subsystem
    IoTHub_Deinit();
}


bool IsSendingEnds()
{
	if (bSendingEnds == false)
		return false;
	bSendingEnds = false;
	return true;
	
}
