/************************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.7.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * Generated Date: 12/24/2019
 ***********************************************************************************************/

#include "sensor_interface.h"

#define MAX_MESSAGE_SIZE 256

bool bSendingEnds = false;

//
// Callback function declarations and DigitalTwin writable (from service side) properties for this interface
//

static void SensorInterface_Property_NameCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext);

static void SensorInterface_Property_BrightnessCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext);

//
//  Callback function declarations and DigitalTwin command names for this interface.
//

static void SensorInterface_Command_BlinkCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext);

static void SensorInterface_Command_TurnonCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext);

static void SensorInterface_Command_TurnoffCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext);

static void SensorInterface_Command_RundiagnosticsCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext);

//
// Application state associated with this interface.
// It contains the DIGITALTWIN_INTERFACE_CLIENT_HANDLE used for responses in callbacks along with properties set
// and representations of the property update and command callbacks invoked on given interface
//
typedef struct SENSOR_INTERFACE_STATE_TAG
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceClientHandle;

    char* name;

    long brightness;

    char* rundiagnosticsRequestId;
    SENSOR_RUNDIAGNOSTICS_STATUS rundiagnosticsStatus;

} SENSOR_INTERFACE_STATE;

static SENSOR_INTERFACE_STATE appState;

// Callback function to process the command "blink".
void SensorInterface_Command_BlinkCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext)
{
    SENSOR_INTERFACE_STATE* interfaceState = (SENSOR_INTERFACE_STATE*)userInterfaceContext;
    LogInfo("SENSOR_INTERFACE: blink command invoked.");
    LogInfo("SENSOR_INTERFACE: blink request payload=<%.*s>, context=<%p>", (int)commandRequest->requestDataLen, commandRequest->requestData, interfaceState);

    // Get payload string
    char* requestData = (char*)malloc(commandRequest->requestDataLen + 1);
    if (requestData != NULL)
    {
        strncpy(requestData, (char*)commandRequest->requestData, commandRequest->requestDataLen);
        requestData[commandRequest->requestDataLen] = 0;
    }
    else
    {
        LogError("Failed to allocate memory for request payload");
    }

    // Parse request parameters from request payload string
    JSON_Value *jsonValue = NULL;
    jsonValue = json_parse_string((const char*)requestData);

    long interval = (long)json_value_get_number(jsonValue);

    // Invoke device command here
    unsigned int statusCode = 200;

    char responsePayload[MAX_MESSAGE_SIZE];

    SENSOR_BLINK_blinkResponse response;

    DIGITALTWIN_COMMAND_RESULT commandResult = Sensor_Command_Blink(interval, &response, &statusCode);

    // Serialize command response payload

    if (commandResult == DIGITALTWIN_COMMAND_OK &&
        Sensor_SerializeBlinkCommandResponse(&response, responsePayload, MAX_MESSAGE_SIZE))
    {
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, (const unsigned char*)responsePayload, statusCode);

    }
    else
    {
        LogError("Failed to execute blink command");
        const unsigned char errorResponse[] = "\"Failed to execute blink command\"";
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, errorResponse, statusCode);
    }

    free(requestData);

    if (jsonValue)
    {
        json_value_free(jsonValue);
    }

}

// Callback function to process the command "turnon".
void SensorInterface_Command_TurnonCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext)
{
    SENSOR_INTERFACE_STATE* interfaceState = (SENSOR_INTERFACE_STATE*)userInterfaceContext;
    LogInfo("SENSOR_INTERFACE: turnon command invoked.");
    LogInfo("SENSOR_INTERFACE: turnon request payload=<%.*s>, context=<%p>", (int)commandRequest->requestDataLen, commandRequest->requestData, interfaceState);

    // Invoke device command here
    unsigned int statusCode = 200;

    DIGITALTWIN_COMMAND_RESULT commandResult = Sensor_Command_Turnon(&statusCode);

    if (commandResult == DIGITALTWIN_COMMAND_OK)
    {
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, NULL, statusCode);

    }
    else
    {
        LogError("Failed to execute turnon command");
        const unsigned char errorResponse[] = "\"Failed to execute turnon command\"";
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, errorResponse, statusCode);
    }

}

// Callback function to process the command "turnoff".
void SensorInterface_Command_TurnoffCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext)
{
    SENSOR_INTERFACE_STATE* interfaceState = (SENSOR_INTERFACE_STATE*)userInterfaceContext;
    LogInfo("SENSOR_INTERFACE: turnoff command invoked.");
    LogInfo("SENSOR_INTERFACE: turnoff request payload=<%.*s>, context=<%p>", (int)commandRequest->requestDataLen, commandRequest->requestData, interfaceState);

    // Invoke device command here
    unsigned int statusCode = 200;

    DIGITALTWIN_COMMAND_RESULT commandResult = Sensor_Command_Turnoff(&statusCode);

    if (commandResult == DIGITALTWIN_COMMAND_OK)
    {
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, NULL, statusCode);

    }
    else
    {
        LogError("Failed to execute turnoff command");
        const unsigned char errorResponse[] = "\"Failed to execute turnoff command\"";
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, errorResponse, statusCode);
    }

}

static const unsigned char Sensor_RundiagnosticsActiveResponse[] = "{ \"result\": \"rundiagnostics async command initiated and in progress\" }";
static const unsigned char Sensor_RundiagnosticsFailureResponse[] = "{ \"result\": \"rundiagnostics failed to process due to internal error\" }";
static const unsigned char Sensor_RundiagnosticsInProgressResponse[] = "{ \"result\": \"rundiagnostics already in progress\" }";
static const unsigned char Sensor_RundiagnosticsRunningState[] = "\"'rundiagnostics' command active\"";
static const unsigned char Sensor_RundiagnosticsSuccessState[] = "\"Process 'rundiagnostics' async command successfully\"";
static const unsigned char Sensor_RundiagnosticsErrorState[] = "\"Process 'rundiagnostics' failed\"";

DIGITALTWIN_CLIENT_RESULT SensorInterface_Rundiagnostics_UpdateStatus(SENSOR_RUNDIAGNOSTICS_STATUS commandStatus,int statusCode)
{
    DIGITALTWIN_CLIENT_RESULT digitalTwinClientResult = DIGITALTWIN_CLIENT_OK;;

    if (commandStatus == SENSOR_RUNDIAGNOSTICS_RUNNING)
    {
        DIGITALTWIN_CLIENT_ASYNC_COMMAND_UPDATE updateInProgress;
        DigitalTwinClientHelper_SetUpdateAsyncStatus(&updateInProgress, SensorInterface_RundiagnosticsCommand, appState.rundiagnosticsRequestId, Sensor_RundiagnosticsRunningState, DIGITALTWIN_ASYNC_STATUS_CODE_PENDING);

        LogInfo("SENSOR_INTERFACE: rundiagnostics command is running.  Updating server process and invoke 'rundiagnostics' async command");
        digitalTwinClientResult = DigitalTwin_InterfaceClient_UpdateAsyncCommandStatusAsync(appState.interfaceClientHandle, &updateInProgress, NULL, NULL);
        if (digitalTwinClientResult != DIGITALTWIN_CLIENT_OK)
        {
            LogError("DigitalTwin_InterfaceClient_UpdateAsyncCommandStatus failed, error=%s.  Continuing execution of thread in any event", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinClientResult));
        }
    }
    else if (commandStatus == SENSOR_RUNDIAGNOSTICS_COMPLETED)
    {
        // Set response as a JSON null when there's no response schema defined in this command
        const unsigned char serializedResponse[] = "null";

        DIGITALTWIN_CLIENT_ASYNC_COMMAND_UPDATE updateComplete;
        DigitalTwinClientHelper_SetUpdateAsyncStatus(&updateComplete, SensorInterface_RundiagnosticsCommand, appState.rundiagnosticsRequestId, serializedResponse, statusCode);
        LogInfo("serializedResponse=%s\r\n",serializedResponse);
		
        digitalTwinClientResult = DigitalTwin_InterfaceClient_UpdateAsyncCommandStatusAsync(appState.interfaceClientHandle, &updateComplete, NULL, NULL);
        if (digitalTwinClientResult != DIGITALTWIN_CLIENT_OK)
        {
            LogError("DigitalTwin_InterfaceClient_UpdateAsyncCommandStatus failed, error=%s.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinClientResult));
        }

        // Reset rundiagnostics status to inactive
        free(appState.rundiagnosticsRequestId);
        appState.rundiagnosticsRequestId = NULL;
        appState.rundiagnosticsStatus = SENSOR_RUNDIAGNOSTICS_INACTIVE;
    }
    else if (commandStatus == SENSOR_RUNDIAGNOSTICS_ERROR)
    {
        DIGITALTWIN_CLIENT_ASYNC_COMMAND_UPDATE updateError;
        DigitalTwinClientHelper_SetUpdateAsyncStatus(&updateError, SensorInterface_RundiagnosticsCommand, appState.rundiagnosticsRequestId, Sensor_RundiagnosticsErrorState, 500);

        digitalTwinClientResult = DigitalTwin_InterfaceClient_UpdateAsyncCommandStatusAsync(appState.interfaceClientHandle, &updateError, NULL, NULL);
        if (digitalTwinClientResult != DIGITALTWIN_CLIENT_OK)
        {
            LogError("DigitalTwin_InterfaceClient_UpdateAsyncCommandStatus failed, error=%s.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinClientResult));
        }

        // Reset rundiagnostics status to inactive
        free(appState.rundiagnosticsRequestId);
        appState.rundiagnosticsRequestId = NULL;
        appState.rundiagnosticsStatus = SENSOR_RUNDIAGNOSTICS_INACTIVE;
    }

    return digitalTwinClientResult;
}

static void SensorInterface_Command_RundiagnosticsCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext)
{
    SENSOR_INTERFACE_STATE* interfaceState = (SENSOR_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SENSOR_INTERFACE: rundiagnostics command invoked.");
    LogInfo("SENSOR_INTERFACE: rundiagnostics request payload=<%.*s>, context=<%p>", (int)commandRequest->requestDataLen, commandRequest->requestData, interfaceState);

    if (interfaceState->rundiagnosticsStatus != SENSOR_RUNDIAGNOSTICS_INACTIVE)
    {
        // If a async command is already in progress, do not allow simultaneous requests.
        // Note that the requirement for only one simultaneous asynchronous command at a time *is for simplifying the generated sample code only*.
        // The underlying DigitalTwin protocol will allow multiple simultaneous requests to be sent to the client; whether the
        // device allows this or not is a decision for the interface & device implementors.
        LogError("SENSOR_INTERFACE: rundiagnostics async command already in progress");
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, Sensor_RundiagnosticsInProgressResponse/*already-in-progress*/, 500);
    }
    else
    {
        // At this point we need to save the requestId.  This is what the server uses to correlate subsequent responses from this operation.
        if (mallocAndStrcpy_s(&interfaceState->rundiagnosticsRequestId, commandRequest->requestId) != 0)
        {
            LogError("SENSOR_INTERFACE: Cannot allocate requestId.");
            (void)DigitalTwinClientHelper_SetCommandResponse(commandResponse, Sensor_RundiagnosticsFailureResponse/*failure*/, 500);
            return;
        }

        if (DigitalTwinClientHelper_SetCommandResponse(commandResponse, Sensor_RundiagnosticsActiveResponse/*initiated-and-in-progress*/, DIGITALTWIN_ASYNC_STATUS_CODE_PENDING) != 0)
        {
            LogError("MXCHIP_INTERFACE: Failed setting response to server.");
            free(appState.rundiagnosticsRequestId);
        }
        else
        {
            // Mark async command is running
            interfaceState->rundiagnosticsStatus = SENSOR_RUNDIAGNOSTICS_RUNNING;

            // Invoke device command here
            Sensor_Command_Rundiagnostics();
        }

    }
}

// DigitalTwinSample_ProcessCommandUpdate receives commands from the server.  This implementation acts as a simple dispatcher
// to the functions to perform the actual processing.
void SensorInterface_ProcessCommandUpdate(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* dtCommandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* dtCommandResponse, void* userInterfaceContext)
{
    if (strcmp(dtCommandRequest->commandName, SensorInterface_BlinkCommand) == 0)
    {
        SensorInterface_Command_BlinkCallback(dtCommandRequest, dtCommandResponse, userInterfaceContext);
        return;
    }

    if (strcmp(dtCommandRequest->commandName, SensorInterface_TurnonCommand) == 0)
    {
        SensorInterface_Command_TurnonCallback(dtCommandRequest, dtCommandResponse, userInterfaceContext);
        return;
    }

    if (strcmp(dtCommandRequest->commandName, SensorInterface_TurnoffCommand) == 0)
    {
        SensorInterface_Command_TurnoffCallback(dtCommandRequest, dtCommandResponse, userInterfaceContext);
        return;
    }

    if (strcmp(dtCommandRequest->commandName, SensorInterface_RundiagnosticsCommand) == 0)
    {
        SensorInterface_Command_RundiagnosticsCallback(dtCommandRequest, dtCommandResponse, userInterfaceContext);
        return;
    }

    // If the command is not implemented by this interface, by convention we return a 501 error to server.
    LogError("SENSOR_INTERFACE: Command name <%s> is not associated with this interface", dtCommandRequest->commandName);
    const unsigned char commandNotImplementedResponse[] = "\"Requested command not implemented on this interface\"";
    (void)DigitalTwinClientHelper_SetCommandResponse(dtCommandResponse, commandNotImplementedResponse, 501);
}

// SensorInterface_PropertyCallback is invoked when a property is updated (or failed) going to server.
// ALL property callbacks will be routed to this function and just have the userContextCallback set to the propertyName.
// Product code will potentially have context stored in this userContextCallback.
static void SensorInterface_PropertyCallback(DIGITALTWIN_CLIENT_RESULT digitalTwinReportedStatus, void* userContextCallback)
{
    if (digitalTwinReportedStatus == DIGITALTWIN_CLIENT_OK)
    {
        ReportProperty_Succeeded_Callback("Sensor", (const char*)userContextCallback);
        LogInfo("SENSOR_INTERFACE: Updating property=<%s> succeeded", (const char*)userContextCallback);
    }
    else
    {
        ReportProperty_Error_Callback("Sensor", (const char*)userContextCallback);
        LogError("SENSOR_INTERFACE: Updating property=<%s> failed, error=<%s>", (const char*)userContextCallback, MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinReportedStatus));
    }
}

// Processes a property update, which the server initiated, for 'name' property.
static void SensorInterface_Property_NameCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    SENSOR_INTERFACE_STATE* interfaceState = (SENSOR_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SENSOR_INTERFACE: name property invoked...");
    LogInfo("SENSOR_INTERFACE: name data=<%.*s>", (int)dtClientPropertyUpdate->propertyDesiredLen, dtClientPropertyUpdate->propertyDesired);

    DIGITALTWIN_CLIENT_PROPERTY_RESPONSE propertyResponse;

    // Version of this structure for C SDK.
    propertyResponse.version = DIGITALTWIN_CLIENT_PROPERTY_RESPONSE_VERSION_1;
    propertyResponse.responseVersion = dtClientPropertyUpdate->desiredVersion;

    if (interfaceState->name != NULL)
    {
        free(interfaceState->name);
    }

    interfaceState->name = (char*)malloc(dtClientPropertyUpdate->propertyDesiredLen + 1);
    if (interfaceState->name == NULL)
    {
        LogError("SENSOR_INTERFACE: Out of memory updating name...");

        // Indicates failure
        propertyResponse.statusCode = 500;
        // Optional additional human readable information about status.
        propertyResponse.statusDescription = "Out of memory";
    }
    else
    {
        strncpy(interfaceState->name, (char*)dtClientPropertyUpdate->propertyDesired, dtClientPropertyUpdate->propertyDesiredLen);
        interfaceState->name[dtClientPropertyUpdate->propertyDesiredLen] = 0;

        LogInfo("SENSOR_INTERFACE: Updating name property with new desired value <%s> ...", dtClientPropertyUpdate->propertyDesired);
        bool updateResult = Sensor_Property_NameCallback(interfaceState->name);

        if (updateResult)
        {
            propertyResponse.statusCode = 200;
            propertyResponse.statusDescription = "name property is updated successfully";
        }
        else
        {
            LogError("SENSOR_INTERFACE: failed to update property name...");

            propertyResponse.statusCode = 500;
            propertyResponse.statusDescription = "failed to update writable property";
        }
    }

    // DigitalTwin_InterfaceClient_ReportPropertyAsync takes the DIGITALTWIN_CLIENT_PROPERTY_RESPONSE and returns information back to service.
    DIGITALTWIN_CLIENT_RESULT result = DigitalTwin_InterfaceClient_ReportPropertyAsync(appState.interfaceClientHandle, SensorInterface_NameProperty, 
        dtClientPropertyUpdate->propertyDesired, dtClientPropertyUpdate->propertyDesiredLen, &propertyResponse,
        SensorInterface_PropertyCallback, SensorInterface_NameProperty);
    if (result != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SENSOR_INTERFACE: DigitalTwin_InterfaceClient_ReportPropertyAsync for name failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }
    else
    {
        LogInfo("SENSOR_INTERFACE: Successfully queued property update for name");
    }
}

// Processes a property update, which the server initiated, for 'brightness' property.
static void SensorInterface_Property_BrightnessCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    SENSOR_INTERFACE_STATE* interfaceState = (SENSOR_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SENSOR_INTERFACE: brightness property invoked...");
    LogInfo("SENSOR_INTERFACE: brightness dataLen=%d,property=%s", (int)dtClientPropertyUpdate->propertyDesiredLen, dtClientPropertyUpdate->propertyDesired);

    DIGITALTWIN_CLIENT_PROPERTY_RESPONSE propertyResponse;

    // Version of this structure for C SDK.
    propertyResponse.version = DIGITALTWIN_CLIENT_PROPERTY_RESPONSE_VERSION_1;
    propertyResponse.responseVersion = dtClientPropertyUpdate->desiredVersion;

    // Parse string value and set updated property
    JSON_Value * jsonValue = json_parse_string((const char*)dtClientPropertyUpdate->propertyDesired);
	LogInfo("SENSOR_INTERFACE:jsonValue=%s\r\n",(const char*)dtClientPropertyUpdate->propertyDesired);

    long newValue = (long)json_value_get_number(jsonValue);
    LogInfo("SENSOR_INTERFACE:newValue=%d\r\n",newValue);
    bool isTypeValid = (json_value_get_type(jsonValue) == JSONNumber && newValue == (long)newValue);
	LogInfo("SENSOR_INTERFACE:isTypeValid=%d\r\n",isTypeValid);

    if (isTypeValid)
    {
        interfaceState->brightness = (long)newValue;

        LogInfo("SENSOR_INTERFACE: Updating brightness property with new value <%s> ...", dtClientPropertyUpdate->propertyDesired);
        bool updateResult = Sensor_Property_BrightnessCallback(interfaceState->brightness);
 
        if (updateResult)
        {
            propertyResponse.statusCode = 200;
            propertyResponse.statusDescription = "brightness property is updated successfully";
        }
        else
        {
            LogError("SENSOR_INTERFACE: failed to update writable property brightness...");

            propertyResponse.statusCode = 500;
            propertyResponse.statusDescription = "failed to update writable property";
        }
    }
    else
    {
        LogError("SENSOR_INTERFACE: Invalid desired value for brightness, value should be Long");
        propertyResponse.statusCode = 500;
        propertyResponse.statusDescription = "Invalid desired value for brightness, value should be Long";
    }
    json_value_free(jsonValue);

    // DigitalTwin_InterfaceClient_ReportPropertyAsync takes the DIGITALTWIN_CLIENT_PROPERTY_RESPONSE and returns information back to service.
    DIGITALTWIN_CLIENT_RESULT result = DigitalTwin_InterfaceClient_ReportPropertyAsync(appState.interfaceClientHandle, SensorInterface_BrightnessProperty, 
        dtClientPropertyUpdate->propertyDesired, dtClientPropertyUpdate->propertyDesiredLen, &propertyResponse,
        SensorInterface_PropertyCallback, SensorInterface_BrightnessProperty);
    if (result != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SENSOR_INTERFACE: DigitalTwin_InterfaceClient_ReportPropertyAsync for brightness failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }
    else
    {
        LogInfo("SENSOR_INTERFACE: Successfully queued property update for brightness");
    }
}

// SensorInterface_ProcessPropertyUpdate receives updated properties from the server.  This implementation
// acts as a simple dispatcher to the functions to perform the actual processing.
static void SensorInterface_ProcessPropertyUpdate(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    if (strcmp(dtClientPropertyUpdate->propertyName, SensorInterface_NameProperty) == 0)
    {
        SensorInterface_Property_NameCallback(dtClientPropertyUpdate, userInterfaceContext);
        return;
    }

    if (strcmp(dtClientPropertyUpdate->propertyName, SensorInterface_BrightnessProperty) == 0)
    {
        SensorInterface_Property_BrightnessCallback(dtClientPropertyUpdate, userInterfaceContext);
        return;
    }

    // If the property is not implemented by this interface, presently we only record a log message but do not have a mechanism to report back to the service
    LogError("SENSOR_INTERFACE: Property name <%s> is not associated with this interface", dtClientPropertyUpdate->propertyName);
}

// SensorInterface_ReportPropertyAsync is a helper function to report a Sensor's properties.
// It invokes underlying DigitalTwin API for reporting properties and sets up its callback on completion.
DIGITALTWIN_CLIENT_RESULT SensorInterface_ReportPropertyAsync(DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceHandle,DIGITALTWIN_DEVICE_CLIENT_LL_HANDLE digitalTwinDeviceClientHandle, const char* propertyName, const char* propertyData)
{
    DIGITALTWIN_CLIENT_RESULT result = DigitalTwin_InterfaceClient_ReportPropertyAsync(interfaceHandle, propertyName,
        (const unsigned char*)propertyData, strlen(propertyData), NULL,
        SensorInterface_PropertyCallback, (void*)propertyName);

    if (result == DIGITALTWIN_CLIENT_OK)
    {
        LogInfo("SENSOR_INTERFACE: Queued async report read only property for %s", propertyName);
        
    }
    else
    {
        LogError("SENSOR_INTERFACE: Reporting property=<%s> failed, error=<%s>", propertyName, MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }

    DigitalTwinClientHelper_Check(digitalTwinDeviceClientHandle);
    return result;
}

DIGITALTWIN_CLIENT_RESULT SensorInterface_Property_ReportState(DIGITALTWIN_DEVICE_CLIENT_LL_HANDLE digitalTwinDeviceClientHandle)
{
    if (appState.interfaceClientHandle == NULL)
    {
        LogError("SENSOR_INTERFACE: interfaceClientHandle is required to be initialized before reporting properties");
    }

    char payloadBuffer[MAX_MESSAGE_SIZE];
    if (Sensor_SerializeStateProperty(payloadBuffer, MAX_MESSAGE_SIZE))
    {
        return SensorInterface_ReportPropertyAsync(appState.interfaceClientHandle, digitalTwinDeviceClientHandle,SensorInterface_StateProperty, payloadBuffer);
    }
    else
    {
        LogError("SENSOR_INTERFACE: serialize read only property state failed");
        return DIGITALTWIN_CLIENT_ERROR;
    }
}

DIGITALTWIN_CLIENT_RESULT SensorInterface_Property_ReportAll(digitalTwinDeviceClientHandle)
{
    DIGITALTWIN_CLIENT_RESULT result;

    // NOTE: Future versions of SDK will support ability to send multiple properties in a single
    // send.  For now, one at a time is sufficient albeit less efficient.
    if (((result = SensorInterface_Property_ReportState(digitalTwinDeviceClientHandle)) != DIGITALTWIN_CLIENT_OK) )

    {
        LogError("DEVICE_INFO: Reporting properties failed.");
    }
    else
    {
        LogInfo("DEVICE_INFO: Queuing of all properties to be reported has succeeded");
    }

    return result;
}

// SensorInterface_TelemetryCallback is invoked when a DigitalTwin telemetry message is either successfully delivered to the service or else fails.
static void SensorInterface_TelemetryCallback(DIGITALTWIN_CLIENT_RESULT digitalTwinTelemetryStatus, void* userContextCallback)
{
	bSendingEnds = true;

    (void)userContextCallback;
    if (digitalTwinTelemetryStatus == DIGITALTWIN_CLIENT_OK)
    {
        SendTelemetry_Succeeded_Callback("Sensor");
        LogInfo("SENSOR_INTERFACE: DigitalTwin successfully delivered telemetry message.");
    }
    else
    {
        SendTelemetry_Error_Callback("Sensor");
        LogError("SENSOR_INTERFACE: DigitalTwin failed to deliver telemetry message, error=<%s> ", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinTelemetryStatus));
    }
}

DIGITALTWIN_CLIENT_RESULT SensorInterface_Telemetry_SendAll()
{
    if (appState.interfaceClientHandle == NULL)
    {
        LogError("SENSOR_INTERFACE: interfaceClientHandle is required to be initialized before sending telemetries");
    }

    DIGITALTWIN_CLIENT_RESULT result;

    char combinedMessage[MAX_MESSAGE_SIZE];
    char telemetryValue[MAX_MESSAGE_SIZE];

    // Send multiple telemetries in a single message
    sprintf(combinedMessage, "{");

    Sensor_SerializeTempTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", SensorInterface_TempTelemetry, telemetryValue);

    Sensor_SerializeHumidTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s", SensorInterface_HumidTelemetry, telemetryValue);

    sprintf(combinedMessage + strlen(combinedMessage), "}");

	LogInfo("\r\ncombinedMessage=%s\r\n",combinedMessage);

    if ((result = DigitalTwin_InterfaceClient_SendTelemetryAsync(appState.interfaceClientHandle, (unsigned char*)combinedMessage, strlen(combinedMessage),
        SensorInterface_TelemetryCallback, NULL)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SENSOR_INTERFACE: DigitalTwin_InterfaceClient_SendTelemetryAsync failed for sending telemetry.");
    }

    return result;
}

DIGITALTWIN_CLIENT_RESULT SensorInterface_Telemetry_Location(char* lat, char* lon)
{
	if (appState.interfaceClientHandle == NULL)
	{
		LogError("SENSOR_INTERFACE: interfaceClientHandle is required to be initialized before sending telemetries");
	}

	DIGITALTWIN_CLIENT_RESULT result;

	char combinedMessage[MAX_MESSAGE_SIZE];
	char telemetryValue[MAX_MESSAGE_SIZE];

	// Send multiple telemetries in a single message
	sprintf(combinedMessage, "{");


	//“devicelocation”: { “lat”: 122, “lon”: 45 }
	Sensor_SerializeTempTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

	sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", SensorInterface_TempTelemetry, telemetryValue);

	Sensor_SerializeHumidTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

	sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", SensorInterface_HumidTelemetry, telemetryValue);


	sprintf(combinedMessage + strlen(combinedMessage), "\"devicelocation\": { \"lat\": %s, \"lon\": %s }", lat, lon);

	sprintf(combinedMessage + strlen(combinedMessage), "}");

	LogInfo("\r\ncombinedMessage=%s\r\n", combinedMessage);

	if ((result = DigitalTwin_InterfaceClient_SendTelemetryAsync(appState.interfaceClientHandle, (unsigned char*)combinedMessage, strlen(combinedMessage),
		SensorInterface_TelemetryCallback, NULL)) != DIGITALTWIN_CLIENT_OK)
	{
		LogError("SENSOR_INTERFACE: DigitalTwin_InterfaceClient_SendTelemetryAsync failed for sending telemetry.");
	}

	return result;
}

// SensorInterface_InterfaceRegisteredCallback is invoked when this interface
// is successfully or unsuccessfully registered with the service, and also when the interface is deleted.
static void SensorInterface_InterfaceRegisteredCallback(DIGITALTWIN_CLIENT_RESULT dtInterfaceStatus, void* userInterfaceContext)
{
    LogInfo("SensorInterface_InterfaceRegisteredCallback with status=<%s>, userContext=<%p>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus), userInterfaceContext);
    if (dtInterfaceStatus == DIGITALTWIN_CLIENT_OK)
    {
        // Once the interface is registered, send our reported properties to the service.  
        // It *IS* safe to invoke most DigitalTwin API calls from a callback thread like this, though it 
        // is NOT safe to create/destroy/register interfaces now.
        LogInfo("SENSOR_INTERFACE: Interface successfully registered.");
    }
    else if (dtInterfaceStatus == DIGITALTWIN_CLIENT_ERROR_INTERFACE_UNREGISTERING)
    {
        // Once an interface is marked as unregistered, it cannot be used for any DigitalTwin SDK calls.
        LogInfo("SENSOR_INTERFACE: Interface received unregistering callback.");
    }
    else
    {
        LogError("SENSOR_INTERFACE: Interface received failed, status=<%s>.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus));
    }
}

//
// Create DigitalTwin interface client handle
//
DIGITALTWIN_INTERFACE_CLIENT_HANDLE SensorInterface_Create()
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceHandle;
    DIGITALTWIN_CLIENT_RESULT result;

    memset(&appState, 0, sizeof(SENSOR_INTERFACE_STATE));

    appState.rundiagnosticsStatus = SENSOR_RUNDIAGNOSTICS_INACTIVE;

    if ((result = DigitalTwin_InterfaceClient_Create(SensorInterfaceId,  SensorInterfaceInstanceName, SensorInterface_InterfaceRegisteredCallback, (void*)&appState, &interfaceHandle)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SENSOR_INTERFACE: Unable to allocate interface client handle for interfaceId=<%s>, interfaceInstanceName=<%s>, error=<%s>", SensorInterfaceId, SensorInterfaceInstanceName, MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        interfaceHandle = NULL;
    }

    else if ((result = DigitalTwin_InterfaceClient_SetPropertiesUpdatedCallback(interfaceHandle, SensorInterface_ProcessPropertyUpdate, (void*)&appState)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SENSOR_INTERFACE: DigitalTwin_InterfaceClient_SetPropertiesUpdatedCallback failed. error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        SensorInterface_Close(interfaceHandle);
        interfaceHandle = NULL;
    }

    else if ((result = DigitalTwin_InterfaceClient_SetCommandsCallback(interfaceHandle, SensorInterface_ProcessCommandUpdate, (void*)&appState)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SENSOR_INTERFACE: DigitalTwin_InterfaceClient_SetCommandsCallbacks failed. error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        SensorInterface_Close(interfaceHandle);
        interfaceHandle = NULL;
    }

    else
    {
        LogInfo("SENSOR_INTERFACE: Created DIGITALTWIN_INTERFACE_CLIENT_HANDLE successfully for interfaceId=<%s>, interfaceInstanceName=<%s>, handle=<%p>", SensorInterfaceId, SensorInterfaceInstanceName, interfaceHandle);
        appState.interfaceClientHandle = interfaceHandle;
		//LogInfo("/r/nsensorinfo.interfaceClientHandle=%d/r/n",interfaceHandle);
    }

    return interfaceHandle;
}

void SensorInterface_Close(DIGITALTWIN_INTERFACE_CLIENT_HANDLE digitalTwinInterfaceClientHandle)
{
    // On shutdown, in general the first call made should be to DigitalTwin_InterfaceClient_Destroy.
    // This will block if there are any active callbacks in this interface, and then
    // mark the underlying handle such that no future callbacks shall come to it.
    DigitalTwin_InterfaceClient_Destroy(digitalTwinInterfaceClientHandle);

    // After DigitalTwin_InterfaceClient_Destroy returns, it is safe to assume
    // no more callbacks shall arrive for this interface and it is OK to free
    // resources callbacks otherwise may have needed.

    if (appState.name != NULL)
    {
        free(appState.name);
        appState.name = NULL;
    }

}
